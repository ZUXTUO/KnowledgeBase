<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>九境美 AI 聊天测试站</title>
  <!-- 引入 highlight.js 样式 -->
  <link rel="stylesheet" href="default.min.css">
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    /* 聊天容器自动适配整个浏览器窗口高度 */
    #chat-container {
      width: 100%;
      max-width: 800px;
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 10px;
    }
    h2 {
      text-align: center;
      background: #25d366;
      color: white;
      margin: 0;
      padding: 15px;
    }
    #status {
      text-align: center;
      font-size: 12px;
      color: #333;
      padding: 5px;
      background: rgba(0, 0, 0, 0.05);
    }
    /* 顶部控制区域 */
    #top-controls {
      text-align: center;
      padding: 10px;
    }
    #messages {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }
    .message {
      margin: 10px 0;
      padding: 10px 15px;
      border-radius: 20px;
      max-width: 75%;
      word-wrap: break-word;
      display: inline-block;
      line-height: 1.5;
    }
    .user { background: #dcf8c6; align-self: flex-end; }
    .bot {
      background: #fff;
      align-self: flex-start;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    #input-container {
      display: flex;
      padding: 10px;
      border-top: 1px solid #ddd;
      background: #fff;
    }
    #user-input {
      flex: 1;
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 20px;
      outline: none;
      font-size: 16px;
    }
    #send-btn, #clear-btn, #toggle-markdown-btn, #toggle-context-btn {
      margin-left: 10px;
      padding: 12px 20px;
      border: none;
      background: #25d366;
      color: white;
      border-radius: 20px;
      cursor: pointer;
      font-size: 16px;
    }
    #send-btn:hover, #clear-btn:hover, #toggle-markdown-btn:hover, #toggle-context-btn:hover {
      background: #1eb85d;
    }
    @media (max-width: 600px) {
      #chat-container { height: 100%; border-radius: 0; }
    }
    /* 悬浮调试面板样式（类似微信风格） */
    #debug-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 320px;
      height: 240px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      font-size: 14px;
      padding: 10px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
    }
    /* 调试面板头部 */
    #debug-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #f0f0f0;
      padding: 5px 10px;
      border-bottom: 1px solid #ccc;
      border-radius: 6px 6px 0 0;
      font-weight: bold;
    }
    #debug-panel-close {
      background: transparent;
      border: none;
      font-size: 16px;
      cursor: pointer;
      color: #888;
    }
    #debug-panel p { margin: 5px 0; }
    /* 新增：网址小卡片样式 */
    .url-card {
        display: inline-flex;
        align-items: center;
        border: 1px solid #25d366;
        border-radius: 12px;
        padding: 8px 12px;
        margin: 5px 0;
        background: #fff;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: transform 0.2s;
    }
    .url-card:hover {
        transform: translateY(-2px);
    }
    .url-card a {
        color: #25d366;
        text-decoration: none;
        font-weight: 500;
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
  </style>
  <!-- 引入 highlight.js 与 marked.js -->
  <script src="highlight.min.js"></script>
  <script src="marked.min.js"></script>
  <script>
    // 配置 marked 自动识别代码块并使用 highlight.js 渲染
    marked.setOptions({
      highlight: function(code, lang) {
        if (lang && hljs.getLanguage(lang)) {
          return hljs.highlight(code, { language: lang }).value;
        } else {
          return hljs.highlightAuto(code).value;
        }
      }
    });
  </script>
</head>
<body>
  <div id="chat-container">
    <h2>奥帆帆 AI 聊天 v2 (3B测试版)</h2>
    <div id="status">测试线程: 15 | GPU占用: 75%</div>
    <!-- 顶部控制区域 -->
    <div id="top-controls">
      <button id="toggle-markdown-btn">开启 Markdown(写代码时使用)</button>
      <button id="toggle-context-btn">关闭上下文(AI记忆混乱时可用)</button>
    </div>
    <div id="messages"></div>
    <div id="input-container">
      <input type="text" id="user-input" placeholder="输入消息...">
      <button id="send-btn">发送</button>
      <button id="clear-btn">清除</button>
    </div>
  </div>
  <!-- 悬浮调试面板 -->
  <div id="debug-panel">
    <div id="debug-panel-header">
      调试日志
      <button id="debug-panel-close">×</button>
    </div>
    <div id="debug-content"></div>
  </div>

  <script>
    // 全局变量控制 Markdown 渲染，及上下文记忆
    let enableMarkdown = false;
    let enableContextMemory = true;
    let contextHistory = "";
    // 存放 data.jsonl 文件中的参考数据
    let referenceData = [];
    // 判断是否是第一次发送消息
    let firstMessage = true;

    // 调试日志函数，将信息输出到调试面板的内容区域
    function logDebug(info) {
      const debugContent = document.getElementById("debug-content");
      const p = document.createElement("p");
      p.textContent = info;
      debugContent.appendChild(p);
      debugContent.scrollTop = debugContent.scrollHeight;
    }

    // 按下 Alt 键显示悬浮调试面板
    document.addEventListener("keydown", function(e) {
      if (e.altKey) {
        document.getElementById("debug-panel").style.display = "block";
      }
    });
    // 调试面板关闭按钮点击事件
    document.getElementById("debug-panel-close").addEventListener("click", function() {
      document.getElementById("debug-panel").style.display = "none";
    });

    // 启动时读取本地 data.jsonl 文件
    fetch('data.jsonl')
      .then(response => response.text())
      .then(text => {
        const lines = text.trim().split("\n");
        lines.forEach(line => {
          try {
            const jsonObj = JSON.parse(line);
            const parts = jsonObj.text.split("\n\n");
            if (parts.length >= 2) {
              const userPart = parts[0].replace(/^User:\s*/i, "");
              const assistantPart = parts[1].replace(/^Assistant:\s*/i, "");
              referenceData.push({ user: userPart, assistant: assistantPart });
            }
          } catch (e) {
            console.error("解析 data.jsonl 时出错:", e);
            logDebug("解析 data.jsonl 时出错: " + e);
          }
        });
        logDebug("成功加载 data.jsonl, 参考数据条数: " + referenceData.length);
      })
      .catch(error => {
        console.error("无法读取 data.jsonl 文件:", error);
        logDebug("无法读取 data.jsonl 文件: " + error);
      });

    // 切换 Markdown 渲染状态
    document.getElementById("toggle-markdown-btn").addEventListener("click", function() {
      enableMarkdown = !enableMarkdown;
      this.textContent = enableMarkdown ? "关闭 Markdown" : "开启 Markdown";
      logDebug("Markdown 状态: " + (enableMarkdown ? "启用" : "关闭"));
    });

    // 切换上下文记忆功能
    document.getElementById("toggle-context-btn").addEventListener("click", function() {
      enableContextMemory = !enableContextMemory;
      this.textContent = enableContextMemory ? "关闭上下文" : "开启上下文";
      if (!enableContextMemory) {
        contextHistory = "";
      }
      logDebug("上下文记忆状态: " + (enableContextMemory ? "开启" : "关闭"));
    });

    // 更新状态显示
    function updateStatus() {
      const userCount = Math.floor(Math.random() * 11) + 10;
      const gpuUsage = Math.floor(Math.random() * 35) + 65;
      document.getElementById("status").textContent = `线程占用: ${userCount} | GPU占用: ${gpuUsage}%`;
    }
    setInterval(updateStatus, 5000);

    // 计算 Levenshtein 距离
    function levenshtein(a, b) {
      const matrix = [];
      const aLen = a.length;
      const bLen = b.length;
      if (aLen === 0) return bLen;
      if (bLen === 0) return aLen;

      for (let i = 0; i <= aLen; i++) {
        matrix[i] = [i];
      }
      for (let j = 0; j <= bLen; j++) {
        matrix[0][j] = j;
      }
      for (let i = 1; i <= aLen; i++) {
        for (let j = 1; j <= bLen; j++) {
          if (a.charAt(i - 1) === b.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j] + 1,
              matrix[i][j - 1] + 1,
              matrix[i - 1][j - 1] + 1
            );
          }
        }
      }
      return matrix[aLen][bLen];
    }

    // 计算相似度比例（0到1之间）；
    // 去除标点符号后再比较
    function similarity(a, b) {
      a = stripPunctuation(a.toLowerCase());
      b = stripPunctuation(b.toLowerCase());
      const distance = levenshtein(a, b);
      const maxLen = Math.max(a.length, b.length);
      if (maxLen === 0) return 1;
      return 1 - distance / maxLen;
    }

    function m_similarity(a, b) {
      a = a.toLowerCase();
      b = b.toLowerCase();
      const distance = levenshtein(a, b);
      const maxLen = Math.max(a.length, b.length);
      if (maxLen === 0) return 1;
      return 1 - distance / maxLen;
    }

    // 去除标点符号（支持中英文）
    function stripPunctuation(str) {
      // 使用 Unicode 属性匹配去除所有标点符号
      return str.replace(/[\p{P}\p{S}]/gu, '');
    }

// 改进后的网址检测函数
function convertUrlsToCards(text) {
    // 增强版正则表达式，支持中文参数和正确边界判断
    const urlRegex = /https?:\/\/(?:www\.)?[\w-]+\.[a-z]{2,}(?:[/?#][^\s<>"'{}\|\\^`。！？，、；：（）【】「」《》“”‘’]*)?/gi;
    
    return text.replace(urlRegex, function(match) {
        // 智能截断尾部标点（保留允许出现在URL中的符号）
        const cleanedUrl = match.replace(/[。！？，；：”’）】〉」》]+$/, '');
        
        try {
            const urlObj = new URL(cleanedUrl);
            // 对解码后的查询参数进行美化处理
            const searchParams = new URLSearchParams(urlObj.search);
            const decodedQuery = Array.from(searchParams.entries())
                .map(([k, v]) => `${k}=${decodeURIComponent(v)}`)
                .join('&');
            
            // 构造更友好的显示文本
            const displayText = decodedQuery 
                ? `${urlObj.hostname}?${decodedQuery}`
                : urlObj.hostname;

            return `
                <div class="url-card" title="${cleanedUrl}">
                    <span style="margin-right:8px">🌍</span>
                    <a href="${cleanedUrl}" target="_blank">${displayText}</a>
                </div>
            `;
        } catch (e) {
            console.warn('无效的URL:', cleanedUrl);
            return match; // 返回原始文本
        }
    });
}

    // 时间相关的问题参考语句（可扩展）
    const timeQuestions = [
        "现在是几点",
        "现在是什么时间",
        "当前时间",
        "现在时间",
        "现在几点了",
        "几点钟了",
        "几点了",
        "现在是早上吗",
        "现在是早晨吗",
        "现在是中午吗",
        "现在是晚上吗",
        "现在是夜晚吗",
        "现在是下午吗",
    ];

    // 修改后的时间检测逻辑
    function checkTimeQuestion(input) {
        // 统一去除标点后比较
        const cleanInput = stripPunctuation(input);
        for (let question of timeQuestions) {
            if (similarity(cleanInput, question) >= 0.5) {
                return true;
            }
        }
        return false;
    }

    // 发送消息（修改为 async 以便等待 person.txt 的获取）
    async function sendMessage() {
      let userMessage = document.getElementById("user-input").value.trim();
      if (userMessage === "") return;

      const messagesDiv = document.getElementById("messages");

      // 显示用户消息
      const userDiv = document.createElement("div");
      userDiv.className = "message user";
      userDiv.textContent = userMessage;
      messagesDiv.appendChild(userDiv);
      document.getElementById("user-input").value = "";

      // 创建显示机器人的消息容器，并显示“正在思考中...”提示
      const botDiv = document.createElement("div");
      botDiv.className = "message bot";
      botDiv.textContent = "奥帆帆正在思考中...";
      messagesDiv.appendChild(botDiv);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;

      // 用于累积机器人的回复内容
      let botMessage = "";
      let hasReceivedData = false;
      let timedOut = false;

      // 超时定时器：10秒内未收到数据则显示“响应超时”
      const timeoutTimer = setTimeout(() => {
        if (!hasReceivedData) {
          timedOut = true;
          botDiv.textContent = "响应超时";
          logDebug("响应超时");
        }
      }, 10000);

      // 构造发送给 AI 的消息，初始为用户输入
      let messageToSend = userMessage;

      // 如果开启上下文记忆，则加入之前对话内容
      if (enableContextMemory) {
        messageToSend = (contextHistory ? contextHistory + "\n" : "") + "User: " + userMessage;
      }

      // 如果用户提问中包含“时间”，附加系统时间
      if (checkTimeQuestion(userMessage)) {
        const nowStr = new Date().toLocaleString();
        messageToSend += "\n系统时间：" + nowStr;
        logDebug("附加系统时间：" + nowStr);
    }

      // 如果是第一次发送消息，则附加 person.txt 的内容（不参与 jsonl 匹配）
      if (firstMessage) {
        try {
          const res = await fetch("person.txt");
          const personText = await res.text();
          messageToSend = "Person Info: " + personText + "\n" + messageToSend;
          logDebug("附加 person.txt 内容");
        } catch (err) {
          logDebug("读取 person.txt 失败: " + err);
        }
        firstMessage = false;
      }

// 双策略相似度计算与择优逻辑‌:ml-citation{ref="1,2" data="citationList"}
let bestMatch = null;
let bestSim = 0;
for (let ref of referenceData) {
  // 并行计算两种相似度‌:ml-citation{ref="2,8" data="citationList"}
  const sim1 = similarity(userMessage, ref.user);    // 去除标点策略
  const sim2 = m_similarity(userMessage, ref.user);  // 保留标点策略
  const currentSim = Math.max(sim1, sim2);           // 择优取最高值‌:ml-citation{ref="1,8" data="citationList"}
  
  if (currentSim > bestSim) {
    bestSim = currentSim;
    bestMatch = ref;
    // 记录优选策略类型‌:ml-citation{ref="8" data="citationList"}
    bestMatch.simType = (sim1 > sim2) ? "去标点策略" : "留标点策略";
  }
}

if (bestSim >= 0.8 && bestMatch) {
  messageToSend += "\n。基于上面这个问题，必须参考下面的答案重复给我：" + bestMatch.assistant;
  // 日志显示双策略结果‌:ml-citation{ref="8" data="citationList"}
  logDebug(`匹配到参考答案，匹配文本：${bestMatch.user} (相似度: ${bestSim.toFixed(2)}, 策略: ${bestMatch.simType})`);
} else {
  logDebug("无匹配参考答案");
}


      // 新增导航检测逻辑
      const navigationRegex = /(带我去|导航到)([^\s，。！？]+)/;
      const navMatch = userMessage.match(navigationRegex);
      if (navMatch && navMatch[2]) {
          const location = navMatch[2].replace(/[。！？]$/, '');  // 去除结尾标点
          const encodedLocation = encodeURIComponent(location);
          messageToSend += `\n（。在这个网址的后面加上我想去的地方，我要求你直接生成网址，不要问我去哪里，只告诉我网址就可以了：https://www.amap.com/search?query=）`;
      }

      logDebug("发送给AI的文本: " + messageToSend);

      // 发送请求到后端
      fetch("chat.php", {
        method: "POST",
        body: new URLSearchParams({ message: messageToSend })
      }).then(response => {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";

        function processStream() {
          reader.read().then(({ done, value }) => {
            if (done || timedOut) return;
            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n");
            buffer = lines.pop();

            for (let line of lines) {
              if (line.startsWith("data: ")) {
                let jsonStr = line.substring(6).trim();
                if (jsonStr === "[DONE]") {
                  if (enableContextMemory) {
                    contextHistory = (contextHistory ? contextHistory + "\n" : "") + "User: " + userMessage + "\nBot: " + botMessage;
                  }
                  logDebug("AI 回复完成: " + botMessage);
                  return;
                }
                try {
                  const dataObj = JSON.parse(jsonStr);
                  if (!hasReceivedData && dataObj.choices && dataObj.choices[0].delta.content) {
                    hasReceivedData = true;
                    clearTimeout(timeoutTimer);
                  }
                  if (dataObj.choices && dataObj.choices[0].delta.content) {
                    botMessage += dataObj.choices[0].delta.content;
                    // 先进行 URL 转换，再根据 Markdown 设置显示
                    const processedMsg = convertUrlsToCards(botMessage);
                    if (enableMarkdown) {
                      botDiv.innerHTML = marked.parse(processedMsg);
                    } else {
                      botDiv.innerHTML = processedMsg;
                    }
                  }
                } catch (e) {
                  console.error("JSON解析失败:", e);
                  logDebug("JSON解析失败: " + e);
                }
              }
            }
            processStream();
          });
        }
        processStream();
      }).catch(err => {
        clearTimeout(timeoutTimer);
        botDiv.textContent = "[错误] " + err;
        logDebug("请求错误: " + err);
      });
    }

    document.getElementById("send-btn").addEventListener("click", sendMessage);
    document.getElementById("clear-btn").addEventListener("click", () => {
      document.getElementById("messages").innerHTML = "";
      // 清空调试面板内容
      document.getElementById("debug-content").innerHTML = "";
      location.reload(); 
    });
    document.getElementById("user-input").addEventListener("keypress", function(event) {
      if (event.key === "Enter") {
        event.preventDefault();
        sendMessage();
      }
    });
  </script>
</body>
</html>
